/*
#pragma warning(disable:4996)
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int hacked()
{
	printf("be hacked");
	return 0;
}

int overflow()
{
	char vul[4];
	const char* x;
	x = "\x08\x09\x10\x11\x12\x13\x14\x15\x60\x15\x01\x04";
	strcpy(vul, x);//调用时会检查参数长度，但是输入错误的长度也可以执行
	//char * y = (char*)malloc(100);
	//strcpy(y, x);
	return 0;
}

int main()
{
	overflow();
}
*/

#include <windows.h>
#include <stdio.h>

char code[] = "\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x58\x3c\x01\xc3\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24\x01\xc1\x89\x4d\xf4\x8b\x53\x14\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51\x68\x65\x78\x65\x00\x68\x70\x61\x64\x2e\x68\x6e\x6f\x74\x65\x89\xe3\x41\x51\x53\xff\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x82\xff\xff\xff\x31\xd2\x52\xff\xd0";


/*int abc()
{
	return 0;
}*/

int main(int argc, char **argv)
{
	int(*func)(); //定义函数指针func，把函数作为变量来使用
	//func = abc;
	DWORD old_protect;
	VirtualProtect(code,sizeof(code),PAGE_EXECUTE_READWRITE,&old_protect);//虚拟内存保护，分页机制
	func = (int(*)()) code;   //对code类型进行强制转换 C语言的处理对象多为指针地址，C++是对象
	(int)(*func)(); //进行函数指针的调用
	{
		//move eax,dword ptr [code]
		//call eax  等效的汇编代码
	}
}

//nasm（汇编器） - f win32 win32 - WinExec_Calc - Exit.asm（汇编文件名） - o win32 - WinExec_Calc - Exit.o（输出文件名）
//将汇编文件转换为.o文件
//for i in $(objdump - D win32 - WinExec_Calc - Exit.o | grep "^ " | cut - f2(以2个字符分隔循环); do echo - n '\x'$i(每个字符前加一个\x); done; echo
//将.o文件打印为可执行的shellcode代码